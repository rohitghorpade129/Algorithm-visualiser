{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Acer\\\\Desktop\\\\New folder\\\\AlgorithmVisualizer\\\\src\\\\pathfinderComponents\\\\pathfinder.jsx\";\nimport React, { Component, Fragment } from 'react';\nimport Grid from \"./grid\";\nimport Navbar from \"./navbar\";\nimport Menu from \"./menu\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\nimport { getMaze } from \"../algorithms/recursiveMaze\";\nimport { bfsdfs } from \"../algorithms/bfs\";\nimport { randomMaze } from \"../algorithms/randomMaze\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nclass Pathfinder extends Component {\n  constructor() {\n    super();\n\n    this.handleMouseDown = (row, col) => {\n      if ((this.state.startNode.row !== row || this.state.startNode.col !== col) && (this.state.endNode.row !== row || this.state.endNode.col !== col)) {\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n        this.setState({\n          grid: newGrid\n        });\n      }\n\n      this.setState({\n        mouseIsPressed: true\n      });\n    };\n\n    this.handleMouseEnter = (row, col) => {\n      if (this.state.mouseIsPressed === false) return;\n\n      if ((this.state.startNode.row !== row || this.state.startNode.col !== col) && (this.state.endNode.row !== row || this.state.endNode.col !== col)) {\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n        this.setState({\n          grid: newGrid\n        });\n      }\n    };\n\n    this.handleMouseUp = (row, col) => {\n      this.setState({\n        mouseIsPressed: false\n      });\n    };\n\n    this.handleAlgoChanged = val => {\n      this.setState({\n        algo: val\n      });\n    };\n\n    this.handleMazeChanged = val => {\n      this.setState({\n        maze: val\n      });\n    };\n\n    this.handleCreateMaze = () => {\n      let pairs;\n\n      switch (this.state.maze) {\n        case 1:\n          pairs = randomMaze(this.state.grid, this.state.row, this.state.col);\n          break;\n\n        default:\n          pairs = getMaze(this.state.grid, this.state.row, this.state.col);\n      }\n\n      const {\n        startNode,\n        endNode\n      } = this.state;\n\n      for (let i = 0; i < pairs.length; i++) {\n        setTimeout(() => {\n          if (i === pairs.length - 1) {\n            // this.setState({grid:this.state.grid});\n            const grid = this.state.grid;\n            grid[startNode.row][startNode.col] = { ...grid[startNode.row][startNode.col],\n              isWall: false\n            };\n            grid[endNode.row][endNode.col] = { ...grid[endNode.row][endNode.col],\n              isWall: false\n            };\n            this.setState({\n              grid\n            });\n          }\n\n          if ((pairs[i].xx !== startNode.row || pairs[i].yy !== startNode.col) && (pairs[i].xx !== endNode.row || pairs[i].yy !== endNode.col)) {\n            document.getElementById(`node-${pairs[i].xx}-${pairs[i].yy}`).className = \"node node-wall\";\n          }\n        }, i * 20);\n      }\n    };\n\n    this.handleClearBoard = () => {\n      const {\n        grid,\n        row,\n        col\n      } = this.state;\n      this.setState({\n        grid: clearBoard(grid, row, col)\n      });\n    };\n\n    this.handleClearPath = () => {\n      const {\n        grid,\n        row,\n        col\n      } = this.state;\n      this.setState({\n        grid: clearPath(grid, row, col)\n      });\n    };\n\n    this.handleClick = () => {\n      /*  for(let i = 0;i<20;i++){\r\n            for(let j = 0; j<50;j++){\r\n                document.getElementById(`node-${i}-${j}`).className = \"node\";\r\n            }\r\n        }*/\n      this.visualizeDijkstra();\n      /*for(let i = 0;i<this.state.row;i++){\r\n          for(let j = 0; j<this.state.col;j++){\r\n              setTimeout(()=>{\r\n                  const newGrid = toggleVisit(this.state.grid,i,j);\r\n                  this.setState({grid:newGrid});\r\n                  //document.getElementById(`node-${i}-${j}`).className = \"node node-visited\";\r\n              },100*(i+j)+j);\r\n          }\r\n      }*/\n    };\n\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      algorithms: [\"Dijsktra\", \"BFS\", \"DFS\"],\n      algo: 0,\n      mazes: [\"Recursive division\", \"Random\", \"Recursive Horizontal bias(NA)\", \"Recursive Vertical bias(NA)\"],\n      maze: 0\n    };\n  }\n\n  componentDidMount() {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const row = Math.max(Math.floor(height / 25) - 7, 10);\n    const col = Math.floor(width / 25);\n    const startNode = {\n      row: 4,\n      col: 4\n    };\n    const endNode = {\n      row: row - 5,\n      col: col - 5\n    };\n    console.log(endNode.row);\n    const grid = getInitialGrid(row, col);\n    grid[startNode.row][startNode.col].isStartNode = true;\n    grid[row - 5][col - 5].isEndNode = true;\n    this.setState({\n      grid,\n      row,\n      col,\n      startNode,\n      endNode\n    });\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(Navbar, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 49,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Menu, {\n        onAlgoChanged: this.handleAlgoChanged,\n        onVisualize: this.handleClick,\n        algorithms: this.state.algorithms,\n        mazes: this.state.mazes,\n        onMazeChanged: this.handleMazeChanged,\n        onCreateMaze: this.handleCreateMaze,\n        onClearBoard: this.handleClearBoard,\n        onClearPath: this.handleClearPath\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 51,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n        style: {\n          margin: 2\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 61,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          textAlign: \"center\"\n        },\n        children: /*#__PURE__*/_jsxDEV(Grid, {\n          grid: this.state.grid,\n          onMouseDown: this.handleMouseDown,\n          onMouseEnter: this.handleMouseEnter,\n          onMouseUp: this.handleMouseUp\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 63,\n          columnNumber: 21\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 62,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 48,\n      columnNumber: 13\n    }, this);\n  }\n\n  visualizeDijkstra() {\n    const {\n      grid\n    } = this.state;\n    const startNode = grid[this.state.startNode.row][this.state.startNode.col];\n    const finishNode = grid[this.state.endNode.row][this.state.endNode.col];\n    let visitedNodesInOrder;\n\n    switch (this.state.algo) {\n      case 0:\n        visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n        break;\n\n      case 1:\n        visitedNodesInOrder = bfsdfs(grid, startNode, finishNode, \"bfs\");\n        break;\n\n      default:\n        visitedNodesInOrder = bfsdfs(grid, startNode, finishNode, \"dfs\");\n    }\n\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  async animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        //  setTimeout(() => {\n        await sleep(100);\n        await this.animateShortestPath(nodesInShortestPathOrder); //  }, 10 * (i+10));\n\n        return;\n      } // setTimeout(() => {\n\n\n      const node = visitedNodesInOrder[i];\n      const newGrid = toggleVisit(this.state.grid, node.row, node.col); //this.setState({grid:newGrid});\n\n      document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n      await sleep(10); // }, 10 * i);\n    }\n  }\n\n  async animateShortestPath(nodesInShortestPathOrder) {\n    const grid = this.state.grid;\n    const newGrid = grid.slice();\n\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      //   setTimeout(() => {\n      const node = nodesInShortestPathOrder[i];\n      const newNode = { ...newGrid[node.row][node.col],\n        ispathNode: true\n      };\n      newGrid[node.row][node.col] = newNode;\n\n      if (i === nodesInShortestPathOrder.length - 1) {\n        this.setState({\n          grid: newGrid\n        });\n      }\n\n      document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n      await sleep(50); //}, 50 * i);\n    }\n  }\n\n}\n\nconst clearPath = (grid, row, col) => {\n  const newGrid = grid.slice();\n\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n      const node = newGrid[i][j];\n      const newNode = { ...node,\n        distance: Infinity,\n        visitedNode: false,\n        isVisited: false,\n        ispathNode: false,\n        previousNode: null\n      };\n      newGrid[i][j] = newNode;\n    }\n  }\n\n  return newGrid;\n};\n\nconst clearBoard = (grid, row, col) => {\n  const newGrid = grid.slice();\n\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n      const node = newGrid[i][j];\n      const newNode = { ...node,\n        isWall: false,\n        distance: Infinity,\n        visitedNode: false,\n        isVisited: false,\n        ispathNode: false,\n        previousNode: null\n      };\n      newGrid[i][j] = newNode;\n    }\n  }\n\n  return newGrid;\n};\n\nconst toggleVisit = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = { ...node,\n    visitedNode: !node.visitedNode\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = { ...node,\n    isWall: true //!node.isWall,\n\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getInitialGrid = (totRow, totCol) => {\n  const grid = [];\n\n  for (let row = 0; row < totRow; row++) {\n    const currentRow = [];\n\n    for (let col = 0; col < totCol; col++) {\n      currentRow.push(createNode(row, col));\n    }\n\n    grid.push(currentRow);\n  }\n\n  return grid;\n};\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isWall: false,\n    isStartNode: false,\n    isEndNode: false,\n    distance: Infinity,\n    visitedNode: false,\n    isVisited: false,\n    ispathNode: false,\n    previousNode: null\n  };\n};\n\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport default Pathfinder;","map":{"version":3,"sources":["C:/Users/Acer/Desktop/New folder/AlgorithmVisualizer/src/pathfinderComponents/pathfinder.jsx"],"names":["React","Component","Fragment","Grid","Navbar","Menu","dijkstra","getNodesInShortestPathOrder","getMaze","bfsdfs","randomMaze","Pathfinder","constructor","handleMouseDown","row","col","state","startNode","endNode","newGrid","getNewGridWithWallToggled","grid","setState","mouseIsPressed","handleMouseEnter","handleMouseUp","handleAlgoChanged","val","algo","handleMazeChanged","maze","handleCreateMaze","pairs","i","length","setTimeout","isWall","xx","yy","document","getElementById","className","handleClearBoard","clearBoard","handleClearPath","clearPath","handleClick","visualizeDijkstra","algorithms","mazes","componentDidMount","width","window","innerWidth","height","innerHeight","Math","max","floor","console","log","getInitialGrid","isStartNode","isEndNode","render","margin","textAlign","finishNode","visitedNodesInOrder","nodesInShortestPathOrder","animateDijkstra","sleep","animateShortestPath","node","toggleVisit","slice","newNode","ispathNode","j","distance","Infinity","visitedNode","isVisited","previousNode","totRow","totCol","currentRow","push","createNode","ms","Promise","resolve"],"mappings":"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","sourcesContent":["import React, {Component, Fragment} from 'react';\r\nimport Grid from \"./grid\";\r\nimport Navbar from \"./navbar\";\r\nimport Menu from \"./menu\";\r\nimport {dijkstra,getNodesInShortestPathOrder} from \"../algorithms/dijkstra\";\r\nimport {getMaze} from \"../algorithms/recursiveMaze\";\r\nimport {bfsdfs} from \"../algorithms/bfs\";\r\nimport {randomMaze} from \"../algorithms/randomMaze\";\r\n\r\nclass Pathfinder extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            grid:[],\r\n            mouseIsPressed:false,\r\n            algorithms:[\r\n                \"Dijsktra\",\"BFS\",\"DFS\"\r\n            ],\r\n            algo:0,\r\n            mazes:[\r\n                \"Recursive division\",\"Random\",\"Recursive Horizontal bias(NA)\",\"Recursive Vertical bias(NA)\"\r\n            ],\r\n            maze:0\r\n        }\r\n    }\r\n    componentDidMount() {\r\n        const width = window.innerWidth;\r\n        const height = window.innerHeight;\r\n        const row = Math.max(Math.floor(height/25)-7,10);\r\n        const col = Math.floor(width/25);\r\n        const startNode = {\r\n            row:4,\r\n            col:4\r\n        };\r\n        const endNode = {\r\n            row: row-5,\r\n            col: col-5\r\n        }\r\n        console.log( endNode.row );\r\n        const grid = getInitialGrid(row,col);\r\n        grid[startNode.row][startNode.col].isStartNode = true;\r\n        grid[row-5][col-5].isEndNode = true;\r\n        this.setState({grid,row,col,startNode,endNode});\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <Fragment>\r\n                <Navbar/>\r\n\r\n                <Menu\r\n                    onAlgoChanged = {this.handleAlgoChanged}\r\n                    onVisualize = {this.handleClick}\r\n                    algorithms={this.state.algorithms}\r\n                    mazes={this.state.mazes}\r\n                    onMazeChanged={this.handleMazeChanged}\r\n                    onCreateMaze={this.handleCreateMaze}\r\n                    onClearBoard={this.handleClearBoard}\r\n                    onClearPath={this.handleClearPath}\r\n                />\r\n                <span style={{margin: 2}}/>\r\n                <div style={{textAlign:\"center\"}} >\r\n                    <Grid\r\n                        grid={this.state.grid}\r\n                        onMouseDown={this.handleMouseDown}\r\n                        onMouseEnter={this.handleMouseEnter}\r\n                        onMouseUp={this.handleMouseUp}\r\n                    />\r\n                </div>\r\n            </Fragment>\r\n        );\r\n    }\r\n\r\n    handleMouseDown = (row, col) => {\r\n        if((this.state.startNode.row!==row || this.state.startNode.col!==col) && (this.state.endNode.row!==row || this.state.endNode.col!==col) ){\r\n            const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n            this.setState({grid:newGrid});\r\n        }\r\n        this.setState({mouseIsPressed: true});\r\n    }\r\n\r\n    handleMouseEnter = (row, col) => {\r\n        if (this.state.mouseIsPressed === false) return;\r\n        if((this.state.startNode.row!==row || this.state.startNode.col!==col) && (this.state.endNode.row!==row || this.state.endNode.col!==col) ){\r\n            const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n            this.setState({grid:newGrid});\r\n        }\r\n    }\r\n\r\n    handleMouseUp = (row,col) => {\r\n        this.setState({mouseIsPressed: false});\r\n    }\r\n\r\n    handleAlgoChanged = (val) =>{\r\n        this.setState({algo:val});\r\n    }\r\n\r\n    handleMazeChanged = (val)=>{\r\n        this.setState({maze:val});\r\n    }\r\n\r\n    handleCreateMaze = () =>{\r\n        let pairs;\r\n        switch (this.state.maze){\r\n            case 1:\r\n                pairs= randomMaze(this.state.grid,this.state.row,this.state.col);\r\n                break;\r\n            default:\r\n                pairs= getMaze(this.state.grid,this.state.row,this.state.col);\r\n        }\r\n        const {startNode,endNode} = this.state;\r\n        for( let i = 0;i<pairs.length;i++ ){\r\n            setTimeout(()=>{\r\n                if( i === pairs.length-1 ){\r\n                   // this.setState({grid:this.state.grid});\r\n                    const grid = this.state.grid;\r\n                    grid[ startNode.row ][startNode.col]={...grid[ startNode.row ][startNode.col],isWall: false};\r\n                    grid[endNode.row][endNode.col]={...grid[endNode.row][endNode.col],isWall: false};\r\n                    this.setState({grid});\r\n                }\r\n                if((pairs[i].xx!==startNode.row || pairs[i].yy!==startNode.col) && (pairs[i].xx!==endNode.row || pairs[i].yy!==endNode.col) ){\r\n                    document.getElementById(`node-${pairs[i].xx}-${pairs[i].yy}`).className = \"node node-wall\";\r\n                }\r\n            },i*20);\r\n        }\r\n    }\r\n    handleClearBoard = ()=>{\r\n        const {grid,row,col} = this.state;\r\n        this.setState({grid:clearBoard(grid,row,col)});\r\n    }\r\n    handleClearPath = () =>{\r\n        const {grid,row,col} = this.state;\r\n        this.setState({grid:clearPath(grid,row,col)});\r\n    }\r\n    handleClick = () =>{\r\n      /*  for(let i = 0;i<20;i++){\r\n            for(let j = 0; j<50;j++){\r\n                document.getElementById(`node-${i}-${j}`).className = \"node\";\r\n            }\r\n        }*/\r\n        this.visualizeDijkstra();\r\n        /*for(let i = 0;i<this.state.row;i++){\r\n            for(let j = 0; j<this.state.col;j++){\r\n                setTimeout(()=>{\r\n                    const newGrid = toggleVisit(this.state.grid,i,j);\r\n                    this.setState({grid:newGrid});\r\n                    //document.getElementById(`node-${i}-${j}`).className = \"node node-visited\";\r\n                },100*(i+j)+j);\r\n            }\r\n        }*/\r\n    }\r\n\r\n    visualizeDijkstra() {\r\n        const {grid} = this.state;\r\n        const startNode = grid[this.state.startNode.row][this.state.startNode.col];\r\n        const finishNode = grid[this.state.endNode.row][this.state.endNode.col];\r\n        let visitedNodesInOrder;\r\n        switch (this.state.algo){\r\n            case 0:\r\n                visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n                break;\r\n            case 1:\r\n                visitedNodesInOrder = bfsdfs(grid, startNode, finishNode,\"bfs\");\r\n                break;\r\n            default:\r\n                visitedNodesInOrder = bfsdfs(grid, startNode, finishNode,\"dfs\");\r\n        }\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n        this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n    async animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n\r\n            if (i === visitedNodesInOrder.length) {\r\n              //  setTimeout(() => {\r\n                    await sleep(100);\r\n                    await this.animateShortestPath(nodesInShortestPathOrder);\r\n\r\n              //  }, 10 * (i+10));\r\n                return;\r\n            }\r\n           // setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                const newGrid = toggleVisit(this.state.grid,node.row,node.col);\r\n                //this.setState({grid:newGrid});\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-visited';\r\n                await sleep(10);\r\n           // }, 10 * i);\r\n        }\r\n    }\r\n\r\n    async animateShortestPath(nodesInShortestPathOrder) {\r\n        const grid = this.state.grid;\r\n        const newGrid = grid.slice();\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n         //   setTimeout(() => {\r\n\r\n                const node = nodesInShortestPathOrder[i];\r\n                const newNode = {...newGrid[node.row][node.col],ispathNode:true};\r\n                newGrid[node.row][node.col] = newNode;\r\n                if( i === nodesInShortestPathOrder.length-1 ){\r\n                    this.setState({grid:newGrid});\r\n                }\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-shortest-path';\r\n                await sleep(50);\r\n            //}, 50 * i);\r\n        }\r\n    }\r\n\r\n}\r\n\r\nconst clearPath = (grid,row,col)=>{\r\n    const newGrid = grid.slice();\r\n    for(let i = 0;i < row ; i++){\r\n        for( let j = 0;j < col; j++){\r\n            const node = newGrid[i][j];\r\n            const newNode = {\r\n                ...node,\r\n                distance:Infinity,\r\n                visitedNode: false,\r\n                isVisited:false,\r\n                ispathNode:false,\r\n                previousNode:null\r\n\r\n            };\r\n            newGrid[i][j] = newNode;\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\nconst clearBoard = (grid,row,col)=>{\r\n    const newGrid = grid.slice();\r\n    for(let i = 0;i < row ; i++){\r\n        for( let j = 0;j < col; j++){\r\n            const node = newGrid[i][j];\r\n            const newNode = {\r\n                ...node,\r\n                isWall: false,\r\n                distance:Infinity,\r\n                visitedNode: false,\r\n                isVisited:false,\r\n                ispathNode:false,\r\n                previousNode:null\r\n\r\n            };\r\n            newGrid[i][j] = newNode;\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\n\r\nconst toggleVisit = (grid,row,col) =>{\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        visitedNode: !node.visitedNode\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: true//!node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\nconst getInitialGrid = (totRow,totCol) => {\r\n    const grid = [];\r\n    for (let row = 0; row < totRow; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < totCol; col++) {\r\n            currentRow.push(createNode(row,col));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\nconst createNode = (row,col)=>{\r\n    return {\r\n        row,\r\n        col,\r\n        isWall: false,\r\n        isStartNode:false,\r\n        isEndNode:false,\r\n        distance:Infinity,\r\n        visitedNode: false,\r\n        isVisited:false,\r\n        ispathNode:false,\r\n        previousNode:null\r\n    };\r\n}\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nexport default Pathfinder;"]},"metadata":{},"sourceType":"module"}